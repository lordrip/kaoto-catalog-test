{
  "type" : "object",
  "properties" : {
    "errorHandler" : {
      "$ref" : "#/definitions/org.apache.camel.model.ErrorHandlerDefinition"
    },
    "id" : {
      "type" : "string"
    },
    "intercept" : {
      "type" : "array",
      "items" : {
        "$ref" : "#/definitions/org.apache.camel.model.InterceptDefinition"
      }
    },
    "interceptFrom" : {
      "type" : "array",
      "items" : {
        "$ref" : "#/definitions/org.apache.camel.model.InterceptFromDefinition"
      }
    },
    "interceptSendToEndpoint" : {
      "type" : "array",
      "items" : {
        "$ref" : "#/definitions/org.apache.camel.model.InterceptSendToEndpointDefinition"
      }
    },
    "onCompletion" : {
      "type" : "array",
      "items" : {
        "$ref" : "#/definitions/org.apache.camel.model.OnCompletionDefinition"
      }
    },
    "onException" : {
      "type" : "array",
      "items" : {
        "$ref" : "#/definitions/org.apache.camel.model.OnExceptionDefinition"
      }
    },
    "precondition" : {
      "type" : "string"
    }
  },
  "$schema" : "http://json-schema.org/draft-04/schema#",
  "definitions" : {
    "org.apache.camel.model.ErrorHandlerDefinition" : {
      "title" : "Error Handler",
      "description" : "Camel error handling.",
      "type" : "object",
      "properties" : {
        "deadLetterChannel" : {
          "$ref" : "#/definitions/org.apache.camel.model.errorhandler.DeadLetterChannelDefinition"
        },
        "defaultErrorHandler" : {
          "$ref" : "#/definitions/org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        },
        "jtaTransactionErrorHandler" : {
          "$ref" : "#/definitions/org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition"
        },
        "noErrorHandler" : {
          "$ref" : "#/definitions/org.apache.camel.model.errorhandler.NoErrorHandlerDefinition"
        },
        "springTransactionErrorHandler" : {
          "$ref" : "#/definitions/org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition"
        }
      }
    },
    "org.apache.camel.model.InterceptDefinition" : {
      "title" : "Intercept",
      "description" : "Intercepts a message at each step in the route",
      "type" : "object",
      "properties" : {
        "description" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "disabled" : {
          "type" : "boolean",
          "title" : "Disabled",
          "description" : "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime."
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "inheritErrorHandler" : {
          "type" : "boolean"
        },
        "steps" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/org.apache.camel.model.ProcessorDefinition"
          }
        }
      }
    },
    "org.apache.camel.model.InterceptFromDefinition" : {
      "title" : "Intercept From",
      "description" : "Intercepts incoming messages",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "disabled" : {
            "type" : "boolean",
            "title" : "Disabled",
            "description" : "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "inheritErrorHandler" : {
            "type" : "boolean"
          },
          "steps" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/org.apache.camel.model.ProcessorDefinition"
            }
          },
          "uri" : {
            "type" : "string",
            "title" : "Uri",
            "description" : "Intercept incoming messages from the uri or uri pattern. If this option is not configured, then all incoming messages is intercepted."
          }
        }
      } ]
    },
    "org.apache.camel.model.InterceptSendToEndpointDefinition" : {
      "title" : "Intercept Send To Endpoint",
      "description" : "Intercepts messages being sent to an endpoint",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "afterUri" : {
            "type" : "string",
            "title" : "After Uri",
            "description" : "After sending to the endpoint then send the message to this uri which allows to process its result."
          },
          "description" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "disabled" : {
            "type" : "boolean",
            "title" : "Disabled",
            "description" : "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "inheritErrorHandler" : {
            "type" : "boolean"
          },
          "skipSendToOriginalEndpoint" : {
            "type" : "string",
            "title" : "Skip Send To Original Endpoint",
            "description" : "If set to true then the message is not sent to the original endpoint. By default (false) the message is both intercepted and then sent to the original endpoint."
          },
          "steps" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/org.apache.camel.model.ProcessorDefinition"
            }
          },
          "uri" : {
            "type" : "string",
            "title" : "Uri",
            "description" : "Intercept sending to the uri or uri pattern."
          }
        }
      } ],
      "required" : [ "uri" ]
    },
    "org.apache.camel.model.OnCompletionDefinition" : {
      "title" : "On Completion",
      "description" : "Route to be executed when normal route processing completes",
      "type" : "object",
      "properties" : {
        "description" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "disabled" : {
          "type" : "boolean",
          "title" : "Disabled",
          "description" : "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime."
        },
        "executorService" : {
          "type" : "string",
          "title" : "Executor Service",
          "description" : "To use a custom Thread Pool to be used for parallel processing. Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well."
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "inheritErrorHandler" : {
          "type" : "boolean"
        },
        "mode" : {
          "type" : "string",
          "title" : "Mode",
          "description" : "Sets the on completion mode. The default value is AfterConsumer",
          "default" : "AfterConsumer",
          "enum" : [ "AfterConsumer", "BeforeConsumer" ]
        },
        "onCompleteOnly" : {
          "type" : "boolean",
          "title" : "On Complete Only",
          "description" : "Will only synchronize when the org.apache.camel.Exchange completed successfully (no errors)."
        },
        "onFailureOnly" : {
          "type" : "boolean",
          "title" : "On Failure Only",
          "description" : "Will only synchronize when the org.apache.camel.Exchange ended with failure (exception or FAULT message)."
        },
        "onWhen" : {
          "title" : "On When",
          "description" : "Sets an additional predicate that should be true before the onCompletion is triggered. To be used for fine grained controlling whether a completion callback should be invoked or not",
          "$ref" : "#/definitions/org.apache.camel.model.WhenDefinition"
        },
        "parallelProcessing" : {
          "type" : "boolean",
          "title" : "Parallel Processing",
          "description" : "If enabled then the on completion process will run asynchronously by a separate thread from a thread pool. By default this is false, meaning the on completion process will run synchronously using the same caller thread as from the route."
        },
        "steps" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/org.apache.camel.model.ProcessorDefinition"
          }
        },
        "useOriginalMessage" : {
          "type" : "boolean",
          "title" : "Use Original Message",
          "description" : "Will use the original input message body when an org.apache.camel.Exchange for this on completion. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the split message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        }
      }
    },
    "org.apache.camel.model.OnExceptionDefinition" : {
      "title" : "On Exception",
      "description" : "Route to be executed when an exception is thrown",
      "type" : "object",
      "properties" : {
        "continued" : {
          "title" : "Continued",
          "description" : "Sets whether the exchange should handle and continue routing from the point of failure. If this option is enabled then its considered handled as well.",
          "$ref" : "#/definitions/org.apache.camel.model.ExpressionSubElementDefinition"
        },
        "description" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "disabled" : {
          "type" : "boolean",
          "title" : "Disabled",
          "description" : "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime."
        },
        "exception" : {
          "type" : "array",
          "title" : "Exception",
          "description" : "A set of exceptions to react upon.",
          "items" : {
            "type" : "string"
          }
        },
        "handled" : {
          "title" : "Handled",
          "description" : "Sets whether the exchange should be marked as handled or not.",
          "$ref" : "#/definitions/org.apache.camel.model.ExpressionSubElementDefinition"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "inheritErrorHandler" : {
          "type" : "boolean"
        },
        "onExceptionOccurredRef" : {
          "type" : "string",
          "title" : "On Exception Occurred Ref",
          "description" : "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored."
        },
        "onRedeliveryRef" : {
          "type" : "string",
          "title" : "On Redelivery Ref",
          "description" : "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered."
        },
        "onWhen" : {
          "title" : "On When",
          "description" : "Sets an additional predicate that should be true before the onException is triggered. To be used for fine grained controlling whether a thrown exception should be intercepted by this exception type or not.",
          "$ref" : "#/definitions/org.apache.camel.model.WhenDefinition"
        },
        "redeliveryPolicy" : {
          "title" : "Redelivery Policy",
          "description" : "Used for configuring redelivery options",
          "$ref" : "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition"
        },
        "redeliveryPolicyRef" : {
          "type" : "string",
          "title" : "Redelivery Policy Ref",
          "description" : "Sets a reference to a redelivery policy to lookup in the org.apache.camel.spi.Registry to be used."
        },
        "retryWhile" : {
          "title" : "Retry While",
          "description" : "Sets the retry while predicate. Will continue retrying until predicate returns false.",
          "$ref" : "#/definitions/org.apache.camel.model.ExpressionSubElementDefinition"
        },
        "steps" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/org.apache.camel.model.ProcessorDefinition"
          }
        },
        "useOriginalBody" : {
          "type" : "boolean",
          "title" : "Use Original Body",
          "description" : "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the split message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        },
        "useOriginalMessage" : {
          "type" : "boolean",
          "title" : "Use Original Message",
          "description" : "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the split message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        }
      }
    },
    "org.apache.camel.model.errorhandler.DeadLetterChannelDefinition" : {
      "title" : "Dead Letter Channel",
      "description" : "Error handler with dead letter queue.",
      "type" : "object",
      "properties" : {
        "deadLetterHandleNewException" : {
          "type" : "boolean",
          "title" : "Dead Letter Handle New Exception",
          "description" : "Whether the dead letter channel should handle (and ignore) any new exception that may been thrown during sending the message to the dead letter endpoint. The default value is true which means any such kind of exception is handled and ignored. Set this to false to let the exception be propagated back on the org.apache.camel.Exchange . This can be used in situations where you use transactions, and want to use Camel's dead letter channel to deal with exceptions during routing, but if the dead letter channel itself fails because of a new exception being thrown, then by setting this to false the new exceptions is propagated back and set on the org.apache.camel.Exchange , which allows the transaction to detect the exception, and rollback."
        },
        "deadLetterUri" : {
          "type" : "string",
          "title" : "Dead Letter Uri",
          "description" : "The dead letter endpoint uri for the Dead Letter error handler."
        },
        "executorServiceRef" : {
          "type" : "string",
          "title" : "Executor Service Ref",
          "description" : "Sets a reference to a thread pool to be used by the error handler"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        },
        "level" : {
          "type" : "string",
          "title" : "Level",
          "description" : "Logging level to use when using the logging error handler type.",
          "default" : "ERROR",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ]
        },
        "logName" : {
          "type" : "string",
          "title" : "Log Name",
          "description" : "Name of the logger to use for the logging error handler"
        },
        "loggerRef" : {
          "type" : "string",
          "title" : "Logger Ref",
          "description" : "References to a logger to use as logger for the error handler"
        },
        "onExceptionOccurredRef" : {
          "type" : "string",
          "title" : "On Exception Occurred Ref",
          "description" : "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored."
        },
        "onPrepareFailureRef" : {
          "type" : "string",
          "title" : "On Prepare Failure Ref",
          "description" : "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue."
        },
        "onRedeliveryRef" : {
          "type" : "string",
          "title" : "On Redelivery Ref",
          "description" : "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered."
        },
        "redeliveryPolicy" : {
          "title" : "Redelivery Policy",
          "description" : "Sets the redelivery settings",
          "$ref" : "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition"
        },
        "redeliveryPolicyRef" : {
          "type" : "string",
          "title" : "Redelivery Policy Ref",
          "description" : "Sets a reference to a RedeliveryPolicy to be used for redelivery settings."
        },
        "retryWhileRef" : {
          "type" : "string",
          "title" : "Retry While Ref",
          "description" : "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false."
        },
        "useOriginalBody" : {
          "type" : "boolean",
          "title" : "Use Original Body",
          "description" : "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        },
        "useOriginalMessage" : {
          "type" : "boolean",
          "title" : "Use Original Message",
          "description" : "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        }
      },
      "required" : [ "deadLetterUri" ]
    },
    "org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition" : {
      "title" : "Default Error Handler",
      "description" : "The default error handler.",
      "type" : "object",
      "properties" : {
        "executorServiceRef" : {
          "type" : "string",
          "title" : "Executor Service Ref",
          "description" : "Sets a reference to a thread pool to be used by the error handler"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        },
        "level" : {
          "type" : "string",
          "title" : "Level",
          "description" : "Logging level to use when using the logging error handler type.",
          "default" : "ERROR",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ]
        },
        "logName" : {
          "type" : "string",
          "title" : "Log Name",
          "description" : "Name of the logger to use for the logging error handler"
        },
        "loggerRef" : {
          "type" : "string",
          "title" : "Logger Ref",
          "description" : "References to a logger to use as logger for the error handler"
        },
        "onExceptionOccurredRef" : {
          "type" : "string",
          "title" : "On Exception Occurred Ref",
          "description" : "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored."
        },
        "onPrepareFailureRef" : {
          "type" : "string",
          "title" : "On Prepare Failure Ref",
          "description" : "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue."
        },
        "onRedeliveryRef" : {
          "type" : "string",
          "title" : "On Redelivery Ref",
          "description" : "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered."
        },
        "redeliveryPolicy" : {
          "title" : "Redelivery Policy",
          "description" : "Sets the redelivery settings",
          "$ref" : "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition"
        },
        "redeliveryPolicyRef" : {
          "type" : "string",
          "title" : "Redelivery Policy Ref",
          "description" : "Sets a reference to a RedeliveryPolicy to be used for redelivery settings."
        },
        "retryWhileRef" : {
          "type" : "string",
          "title" : "Retry While Ref",
          "description" : "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false."
        },
        "useOriginalBody" : {
          "type" : "boolean",
          "title" : "Use Original Body",
          "description" : "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        },
        "useOriginalMessage" : {
          "type" : "boolean",
          "title" : "Use Original Message",
          "description" : "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        }
      }
    },
    "org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition" : {
      "title" : "Jta Transaction Error Handler",
      "description" : "JTA based transactional error handler (requires camel-jta).",
      "type" : "object",
      "properties" : {
        "executorServiceRef" : {
          "type" : "string",
          "title" : "Executor Service Ref",
          "description" : "Sets a reference to a thread pool to be used by the error handler"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        },
        "level" : {
          "type" : "string",
          "title" : "Level",
          "description" : "Logging level to use when using the logging error handler type.",
          "default" : "ERROR",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ]
        },
        "logName" : {
          "type" : "string",
          "title" : "Log Name",
          "description" : "Name of the logger to use for the logging error handler"
        },
        "loggerRef" : {
          "type" : "string",
          "title" : "Logger Ref",
          "description" : "References to a logger to use as logger for the error handler"
        },
        "onExceptionOccurredRef" : {
          "type" : "string",
          "title" : "On Exception Occurred Ref",
          "description" : "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored."
        },
        "onPrepareFailureRef" : {
          "type" : "string",
          "title" : "On Prepare Failure Ref",
          "description" : "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue."
        },
        "onRedeliveryRef" : {
          "type" : "string",
          "title" : "On Redelivery Ref",
          "description" : "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered."
        },
        "redeliveryPolicy" : {
          "title" : "Redelivery Policy",
          "description" : "Sets the redelivery settings",
          "$ref" : "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition"
        },
        "redeliveryPolicyRef" : {
          "type" : "string",
          "title" : "Redelivery Policy Ref",
          "description" : "Sets a reference to a RedeliveryPolicy to be used for redelivery settings."
        },
        "retryWhileRef" : {
          "type" : "string",
          "title" : "Retry While Ref",
          "description" : "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false."
        },
        "rollbackLoggingLevel" : {
          "type" : "string",
          "title" : "Rollback Logging Level",
          "description" : "Sets the logging level to use for logging transactional rollback. This option is default WARN.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ]
        },
        "transactedPolicyRef" : {
          "type" : "string",
          "title" : "Transacted Policy Ref",
          "description" : "The transacted policy to use that is configured for either Spring or JTA based transactions. If no policy has been configured then Camel will attempt to auto-discover."
        },
        "useOriginalBody" : {
          "type" : "boolean",
          "title" : "Use Original Body",
          "description" : "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        },
        "useOriginalMessage" : {
          "type" : "boolean",
          "title" : "Use Original Message",
          "description" : "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        }
      }
    },
    "org.apache.camel.model.errorhandler.NoErrorHandlerDefinition" : {
      "title" : "No Error Handler",
      "description" : "To not use an error handler.",
      "type" : "object",
      "properties" : {
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        }
      }
    },
    "org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition" : {
      "title" : "Spring Transaction Error Handler",
      "description" : "Spring based transactional error handler (requires camel-spring).",
      "type" : "object",
      "properties" : {
        "executorServiceRef" : {
          "type" : "string",
          "title" : "Executor Service Ref",
          "description" : "Sets a reference to a thread pool to be used by the error handler"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        },
        "level" : {
          "type" : "string",
          "title" : "Level",
          "description" : "Logging level to use when using the logging error handler type.",
          "default" : "ERROR",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ]
        },
        "logName" : {
          "type" : "string",
          "title" : "Log Name",
          "description" : "Name of the logger to use for the logging error handler"
        },
        "loggerRef" : {
          "type" : "string",
          "title" : "Logger Ref",
          "description" : "References to a logger to use as logger for the error handler"
        },
        "onExceptionOccurredRef" : {
          "type" : "string",
          "title" : "On Exception Occurred Ref",
          "description" : "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored."
        },
        "onPrepareFailureRef" : {
          "type" : "string",
          "title" : "On Prepare Failure Ref",
          "description" : "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue."
        },
        "onRedeliveryRef" : {
          "type" : "string",
          "title" : "On Redelivery Ref",
          "description" : "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered."
        },
        "redeliveryPolicy" : {
          "title" : "Redelivery Policy",
          "description" : "Sets the redelivery settings",
          "$ref" : "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition"
        },
        "redeliveryPolicyRef" : {
          "type" : "string",
          "title" : "Redelivery Policy Ref",
          "description" : "Sets a reference to a RedeliveryPolicy to be used for redelivery settings."
        },
        "retryWhileRef" : {
          "type" : "string",
          "title" : "Retry While Ref",
          "description" : "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false."
        },
        "rollbackLoggingLevel" : {
          "type" : "string",
          "title" : "Rollback Logging Level",
          "description" : "Sets the logging level to use for logging transactional rollback. This option is default WARN.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ]
        },
        "transactedPolicyRef" : {
          "type" : "string",
          "title" : "Transacted Policy Ref",
          "description" : "The transacted policy to use that is configured for either Spring or JTA based transactions. If no policy has been configured then Camel will attempt to auto-discover."
        },
        "useOriginalBody" : {
          "type" : "boolean",
          "title" : "Use Original Body",
          "description" : "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        },
        "useOriginalMessage" : {
          "type" : "boolean",
          "title" : "Use Original Message",
          "description" : "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off."
        }
      }
    },
    "org.apache.camel.model.WhenDefinition" : {
      "title" : "When",
      "description" : "Triggers a route when the expression evaluates to true",
      "type" : "object",
      "anyOf" : [ {
        "$ref" : "#/definitions/org.apache.camel.model.language.ExpressionDefinition"
      } ],
      "properties" : {
        "description" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "disabled" : {
          "type" : "boolean",
          "title" : "Disabled",
          "description" : "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime."
        },
        "expression" : {
          "title" : "Expression",
          "description" : "Expression used as the predicate to evaluate whether this when should trigger and route the message or not.",
          "$ref" : "#/definitions/org.apache.camel.model.language.ExpressionDefinition"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "inheritErrorHandler" : {
          "type" : "boolean"
        },
        "steps" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/org.apache.camel.model.ProcessorDefinition"
          }
        }
      }
    },
    "org.apache.camel.model.ExpressionSubElementDefinition" : {
      "type" : "object",
      "properties" : {
        "constant" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.ConstantExpression"
        },
        "csimple" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.CSimpleExpression"
        },
        "datasonnet" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.DatasonnetExpression"
        },
        "exchangeProperty" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.ExchangePropertyExpression"
        },
        "groovy" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.GroovyExpression"
        },
        "header" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.HeaderExpression"
        },
        "hl7terser" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.Hl7TerserExpression"
        },
        "joor" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JoorExpression"
        },
        "jq" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JqExpression"
        },
        "js" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JavaScriptExpression"
        },
        "jsonpath" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JsonPathExpression"
        },
        "language" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.LanguageExpression"
        },
        "method" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.MethodCallExpression"
        },
        "mvel" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.MvelExpression"
        },
        "ognl" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.OgnlExpression"
        },
        "python" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.PythonExpression"
        },
        "ref" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.RefExpression"
        },
        "simple" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.SimpleExpression"
        },
        "spel" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.SpELExpression"
        },
        "tokenize" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.TokenizerExpression"
        },
        "xpath" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.XPathExpression"
        },
        "xquery" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.XQueryExpression"
        },
        "xtokenize" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.XMLTokenizerExpression"
        }
      }
    },
    "org.apache.camel.model.RedeliveryPolicyDefinition" : {
      "title" : "Redelivery Policy",
      "description" : "To configure re-delivery for error handling",
      "type" : "object",
      "properties" : {
        "allowRedeliveryWhileStopping" : {
          "type" : "boolean",
          "title" : "Allow Redelivery While Stopping",
          "description" : "Controls whether to allow redelivery while stopping/shutting down a route that uses error handling."
        },
        "asyncDelayedRedelivery" : {
          "type" : "boolean",
          "title" : "Async Delayed Redelivery",
          "description" : "Allow asynchronous delayed redelivery. The route, in particular the consumer's component, must support the Asynchronous Routing Engine (e.g. seda)."
        },
        "backOffMultiplier" : {
          "type" : "number",
          "title" : "Back Off Multiplier",
          "description" : "Sets the back off multiplier",
          "default" : "2.0"
        },
        "collisionAvoidanceFactor" : {
          "type" : "number",
          "title" : "Collision Avoidance Factor",
          "description" : "Sets the collision avoidance factor",
          "default" : "0.15"
        },
        "delayPattern" : {
          "type" : "string",
          "title" : "Delay Pattern",
          "description" : "Sets the delay pattern with delay intervals."
        },
        "disableRedelivery" : {
          "type" : "boolean",
          "title" : "Disable Redelivery",
          "description" : "Disables redelivery (same as setting maximum redeliveries to 0)"
        },
        "exchangeFormatterRef" : {
          "type" : "string",
          "title" : "Exchange Formatter Ref",
          "description" : "Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange."
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "The id of this node"
        },
        "logContinued" : {
          "type" : "boolean",
          "title" : "Log Continued",
          "description" : "Sets whether continued exceptions should be logged or not. Can be used to include or reduce verbose."
        },
        "logExhausted" : {
          "type" : "boolean",
          "title" : "Log Exhausted",
          "description" : "Sets whether exhausted exceptions should be logged or not. Can be used to include or reduce verbose."
        },
        "logExhaustedMessageBody" : {
          "type" : "boolean",
          "title" : "Log Exhausted Message Body",
          "description" : "Sets whether exhausted message body should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose. Requires logExhaustedMessageHistory to be enabled."
        },
        "logExhaustedMessageHistory" : {
          "type" : "boolean",
          "title" : "Log Exhausted Message History",
          "description" : "Sets whether exhausted exceptions should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose."
        },
        "logHandled" : {
          "type" : "boolean",
          "title" : "Log Handled",
          "description" : "Sets whether handled exceptions should be logged or not. Can be used to include or reduce verbose."
        },
        "logNewException" : {
          "type" : "boolean",
          "title" : "Log New Exception",
          "description" : "Sets whether new exceptions should be logged or not. Can be used to include or reduce verbose. A new exception is an exception that was thrown while handling a previous exception."
        },
        "logRetryAttempted" : {
          "type" : "boolean",
          "title" : "Log Retry Attempted",
          "description" : "Sets whether retry attempts should be logged or not. Can be used to include or reduce verbose."
        },
        "logRetryStackTrace" : {
          "type" : "boolean",
          "title" : "Log Retry Stack Trace",
          "description" : "Sets whether stack traces should be logged when an retry attempt failed. Can be used to include or reduce verbose."
        },
        "logStackTrace" : {
          "type" : "boolean",
          "title" : "Log Stack Trace",
          "description" : "Sets whether stack traces should be logged. Can be used to include or reduce verbose."
        },
        "maximumRedeliveries" : {
          "type" : "number",
          "title" : "Maximum Redeliveries",
          "description" : "Sets the maximum redeliveries x = redeliver at most x times 0 = no redeliveries -1 = redeliver forever"
        },
        "maximumRedeliveryDelay" : {
          "type" : "string",
          "title" : "Maximum Redelivery Delay",
          "description" : "Sets the maximum delay between redelivery",
          "default" : "60000"
        },
        "redeliveryDelay" : {
          "type" : "string",
          "title" : "Redelivery Delay",
          "description" : "Sets the initial redelivery delay",
          "default" : "1000"
        },
        "retriesExhaustedLogLevel" : {
          "type" : "string",
          "title" : "Retries Exhausted Log Level",
          "description" : "Sets the logging level to use when retries have been exhausted",
          "default" : "ERROR"
        },
        "retryAttemptedLogInterval" : {
          "type" : "number",
          "title" : "Retry Attempted Log Interval",
          "description" : "Sets the interval to use for logging retry attempts",
          "default" : "1"
        },
        "retryAttemptedLogLevel" : {
          "type" : "string",
          "title" : "Retry Attempted Log Level",
          "description" : "Sets the logging level to use for logging retry attempts",
          "default" : "DEBUG"
        },
        "useCollisionAvoidance" : {
          "type" : "boolean",
          "title" : "Use Collision Avoidance",
          "description" : "Turn on collision avoidance."
        },
        "useExponentialBackOff" : {
          "type" : "boolean",
          "title" : "Use Exponential Back Off",
          "description" : "Turn on exponential backk off"
        }
      }
    },
    "org.apache.camel.model.language.ExpressionDefinition" : {
      "type" : "object",
      "properties" : {
        "constant" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.ConstantExpression"
        },
        "csimple" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.CSimpleExpression"
        },
        "datasonnet" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.DatasonnetExpression"
        },
        "exchangeProperty" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.ExchangePropertyExpression"
        },
        "groovy" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.GroovyExpression"
        },
        "header" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.HeaderExpression"
        },
        "hl7terser" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.Hl7TerserExpression"
        },
        "joor" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JoorExpression"
        },
        "jq" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JqExpression"
        },
        "js" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JavaScriptExpression"
        },
        "jsonpath" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.JsonPathExpression"
        },
        "language" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.LanguageExpression"
        },
        "method" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.MethodCallExpression"
        },
        "mvel" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.MvelExpression"
        },
        "ognl" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.OgnlExpression"
        },
        "python" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.PythonExpression"
        },
        "ref" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.RefExpression"
        },
        "simple" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.SimpleExpression"
        },
        "spel" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.SpELExpression"
        },
        "tokenize" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.TokenizerExpression"
        },
        "xpath" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.XPathExpression"
        },
        "xquery" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.XQueryExpression"
        },
        "xtokenize" : {
          "$ref" : "#/definitions/org.apache.camel.model.language.XMLTokenizerExpression"
        }
      }
    },
    "org.apache.camel.model.language.ConstantExpression" : {
      "title" : "Constant",
      "description" : "A fixed value set only once during the route startup.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.CSimpleExpression" : {
      "title" : "CSimple",
      "description" : "Evaluate a compiled simple expression.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.DatasonnetExpression" : {
      "title" : "DataSonnet",
      "description" : "To use DataSonnet scripts for message transformations.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "bodyMediaType" : {
            "type" : "string",
            "title" : "Body Media Type",
            "description" : "The String representation of the message's body MediaType"
          },
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "outputMediaType" : {
            "type" : "string",
            "title" : "Output Media Type",
            "description" : "The String representation of the MediaType to output"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.ExchangePropertyExpression" : {
      "title" : "ExchangeProperty",
      "description" : "Gets a property from the Exchange.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.GroovyExpression" : {
      "title" : "Groovy",
      "description" : "Evaluates a Groovy script.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.HeaderExpression" : {
      "title" : "Header",
      "description" : "Gets a header from the Exchange.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.Hl7TerserExpression" : {
      "title" : "HL7 Terser",
      "description" : "Get the value of a HL7 message field specified by terse location specification syntax.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.JoorExpression" : {
      "title" : "jOOR",
      "description" : "Evaluates a jOOR (Java compiled once at runtime) expression.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "preCompile" : {
            "type" : "boolean",
            "title" : "Pre Compile",
            "description" : "Whether the expression should be pre compiled once during initialization phase. If this is turned off, then the expression is reloaded and compiled on each evaluation."
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "singleQuotes" : {
            "type" : "boolean",
            "title" : "Single Quotes",
            "description" : "Whether single quotes can be used as replacement for double quotes. This is convenient when you need to work with strings inside strings."
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.JqExpression" : {
      "title" : "JQ",
      "description" : "Evaluates a JQ expression against a JSON message body.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.JavaScriptExpression" : {
      "title" : "JavaScript",
      "description" : "Evaluates a JavaScript expression.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.JsonPathExpression" : {
      "title" : "JSONPath",
      "description" : "Evaluates a JSONPath expression against a JSON message body.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "allowEasyPredicate" : {
            "type" : "boolean",
            "title" : "Allow Easy Predicate",
            "description" : "Whether to allow using the easy predicate parser to pre-parse predicates."
          },
          "allowSimple" : {
            "type" : "boolean",
            "title" : "Allow Simple",
            "description" : "Whether to allow in inlined Simple exceptions in the JSONPath expression"
          },
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "option" : {
            "type" : "string",
            "title" : "Option",
            "description" : "To configure additional options on JSONPath. Multiple values can be separated by comma.",
            "enum" : [ "DEFAULT_PATH_LEAF_TO_NULL", "ALWAYS_RETURN_LIST", "AS_PATH_LIST", "SUPPRESS_EXCEPTIONS", "REQUIRE_PROPERTIES" ]
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "suppressExceptions" : {
            "type" : "boolean",
            "title" : "Suppress Exceptions",
            "description" : "Whether to suppress exceptions such as PathNotFoundException."
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          },
          "unpackArray" : {
            "type" : "boolean",
            "title" : "Unpack Array",
            "description" : "Whether to unpack a single element json-array into an object."
          },
          "writeAsString" : {
            "type" : "boolean",
            "title" : "Write As String",
            "description" : "Whether to write the output of each row/element as a JSON String value instead of a Map/POJO value."
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.LanguageExpression" : {
      "title" : "Language",
      "description" : "Evaluates a custom language.",
      "type" : "object",
      "properties" : {
        "expression" : {
          "type" : "string",
          "title" : "Expression",
          "description" : "The expression value in your chosen language syntax"
        },
        "id" : {
          "type" : "string",
          "title" : "Id",
          "description" : "Sets the id of this node"
        },
        "language" : {
          "type" : "string",
          "title" : "Language",
          "description" : "The name of the language to use"
        },
        "trim" : {
          "type" : "boolean",
          "title" : "Trim",
          "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
        }
      },
      "required" : [ "expression", "language" ]
    },
    "org.apache.camel.model.language.MethodCallExpression" : {
      "title" : "Bean Method",
      "description" : "Calls a Java bean method.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "beanType" : {
            "type" : "string",
            "title" : "Bean Type",
            "description" : "Class name (fully qualified) of the bean to use Will lookup in registry and if there is a single instance of the same type, then the existing bean is used, otherwise a new bean is created (requires a default no-arg constructor)."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "method" : {
            "type" : "string",
            "title" : "Method",
            "description" : "Name of method to call"
          },
          "ref" : {
            "type" : "string",
            "title" : "Ref",
            "description" : "Reference to an existing bean (bean id) to lookup in the registry"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "scope" : {
            "type" : "string",
            "title" : "Scope",
            "description" : "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. So when using prototype scope then this depends on the bean registry implementation.",
            "default" : "Singleton",
            "enum" : [ "Singleton", "Request", "Prototype" ]
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ]
    },
    "org.apache.camel.model.language.MvelExpression" : {
      "title" : "MVEL",
      "description" : "Evaluates a MVEL template.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.OgnlExpression" : {
      "title" : "OGNL",
      "description" : "Evaluates an OGNL expression (Apache Commons OGNL).",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.PythonExpression" : {
      "title" : "Python",
      "description" : "Evaluates a Python expression.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.RefExpression" : {
      "title" : "Ref",
      "description" : "Uses an existing expression from the registry.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.SimpleExpression" : {
      "title" : "Simple",
      "description" : "Evaluates a Camel simple expression.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.SpELExpression" : {
      "title" : "SpEL",
      "description" : "Evaluates a Spring expression (SpEL).",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.TokenizerExpression" : {
      "title" : "Tokenize",
      "description" : "Tokenize text payloads using delimiter patterns.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "endToken" : {
            "type" : "string",
            "title" : "End Token",
            "description" : "The end token to use as tokenizer if using start/end token pairs. You can use simple language as the token to support dynamic tokens."
          },
          "group" : {
            "type" : "string",
            "title" : "Group",
            "description" : "To group N parts together, for example to split big files into chunks of 1000 lines. You can use simple language as the group to support dynamic group sizes."
          },
          "groupDelimiter" : {
            "type" : "string",
            "title" : "Group Delimiter",
            "description" : "Sets the delimiter to use when grouping. If this has not been set then token will be used as the delimiter."
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "includeTokens" : {
            "type" : "boolean",
            "title" : "Include Tokens",
            "description" : "Whether to include the tokens in the parts when using pairs. When including tokens then the endToken property must also be configured (to use pair mode). The default value is false"
          },
          "inheritNamespaceTagName" : {
            "type" : "string",
            "title" : "Inherit Namespace Tag Name",
            "description" : "To inherit namespaces from a root/parent tag name when using XML You can use simple language as the tag name to support dynamic names."
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "regex" : {
            "type" : "boolean",
            "title" : "Regex",
            "description" : "If the token is a regular expression pattern. The default value is false"
          },
          "skipFirst" : {
            "type" : "boolean",
            "title" : "Skip First",
            "description" : "To skip the very first element"
          },
          "token" : {
            "type" : "string",
            "title" : "Token",
            "description" : "The (start) token to use as tokenizer, for example you can use the new line token. You can use simple language as the token to support dynamic tokens."
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          },
          "xml" : {
            "type" : "boolean",
            "title" : "Xml",
            "description" : "Whether the input is XML messages. This option must be set to true if working with XML payloads."
          }
        }
      } ],
      "required" : [ "token" ]
    },
    "org.apache.camel.model.language.XPathExpression" : {
      "title" : "XPath",
      "description" : "Evaluates an XPath expression against an XML payload.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "documentType" : {
            "type" : "string",
            "title" : "Document Type",
            "description" : "Name of class for document type The default value is org.w3c.dom.Document"
          },
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "factoryRef" : {
            "type" : "string",
            "title" : "Factory Ref",
            "description" : "References to a custom XPathFactory to lookup in the registry"
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "logNamespaces" : {
            "type" : "boolean",
            "title" : "Log Namespaces",
            "description" : "Whether to log namespaces which can assist during troubleshooting"
          },
          "namespace" : {
            "type" : "array",
            "title" : "Namespace",
            "description" : "Injects the XML Namespaces of prefix - uri mappings",
            "items" : {
              "$ref" : "#/definitions/org.apache.camel.model.PropertyDefinition"
            }
          },
          "objectModel" : {
            "type" : "string",
            "title" : "Object Model",
            "description" : "The XPath object model to use"
          },
          "preCompile" : {
            "type" : "boolean",
            "title" : "Pre Compile",
            "description" : "Whether to enable pre-compiling the xpath expression during initialization phase. pre-compile is enabled by default. This can be used to turn off, for example in cases the compilation phase is desired at the starting phase, such as if the application is ahead of time compiled (for example with camel-quarkus) which would then load the xpath factory of the built operating system, and not a JVM runtime."
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class name of the result type (type from output) The default result type is NodeSet",
            "default" : "NODESET",
            "enum" : [ "NUMBER", "STRING", "BOOLEAN", "NODESET", "NODE" ]
          },
          "saxon" : {
            "type" : "boolean",
            "title" : "Saxon",
            "description" : "Whether to use Saxon."
          },
          "threadSafety" : {
            "type" : "boolean",
            "title" : "Thread Safety",
            "description" : "Whether to enable thread-safety for the returned result of the xpath expression. This applies to when using NODESET as the result type, and the returned set has multiple elements. In this situation there can be thread-safety issues if you process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode. This option prevents concurrency issues by doing defensive copies of the nodes. It is recommended to turn this option on if you are using camel-saxon or Saxon in your application. Saxon has thread-safety issues which can be prevented by turning this option on."
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.XQueryExpression" : {
      "title" : "XQuery",
      "description" : "Evaluates an XQuery expressions against an XML payload.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "configurationRef" : {
            "type" : "string",
            "title" : "Configuration Ref",
            "description" : "Reference to a saxon configuration instance in the registry to use for xquery (requires camel-saxon). This may be needed to add custom functions to a saxon configuration, so these custom functions can be used in xquery expressions."
          },
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "namespace" : {
            "type" : "array",
            "title" : "Namespace",
            "description" : "Injects the XML Namespaces of prefix - uri mappings",
            "items" : {
              "$ref" : "#/definitions/org.apache.camel.model.PropertyDefinition"
            }
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "resultType" : {
            "type" : "string",
            "title" : "Result Type",
            "description" : "Sets the class of the result type (type from output)"
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          },
          "type" : {
            "type" : "string",
            "title" : "Type",
            "description" : "Sets the class name of the result type (type from output) The default result type is NodeSet"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.language.XMLTokenizerExpression" : {
      "title" : "XML Tokenize",
      "description" : "Tokenize XML payloads.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "object",
        "properties" : {
          "expression" : {
            "type" : "string",
            "title" : "Expression",
            "description" : "The expression value in your chosen language syntax"
          },
          "group" : {
            "type" : "number",
            "title" : "Group",
            "description" : "To group N parts together"
          },
          "headerName" : {
            "type" : "string",
            "title" : "Header Name",
            "description" : "Name of header to use as input, instead of the message body It has as higher precedent than the propertyName if both are set."
          },
          "id" : {
            "type" : "string",
            "title" : "Id",
            "description" : "Sets the id of this node"
          },
          "mode" : {
            "type" : "string",
            "title" : "Mode",
            "description" : "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element",
            "default" : "i",
            "enum" : [ "i", "w", "u", "t" ]
          },
          "namespace" : {
            "type" : "array",
            "title" : "Namespace",
            "description" : "Injects the XML Namespaces of prefix - uri mappings",
            "items" : {
              "$ref" : "#/definitions/org.apache.camel.model.PropertyDefinition"
            }
          },
          "propertyName" : {
            "type" : "string",
            "title" : "Property Name",
            "description" : "Name of property to use as input, instead of the message body. It has a lower precedent than the headerName if both are set."
          },
          "trim" : {
            "type" : "boolean",
            "title" : "Trim",
            "description" : "Whether to trim the value to remove leading and trailing whitespaces and line breaks"
          }
        }
      } ],
      "required" : [ "expression" ]
    },
    "org.apache.camel.model.PropertyDefinition" : {
      "title" : "Property",
      "description" : "A key value pair where the value is a literal value",
      "type" : "object",
      "properties" : {
        "key" : {
          "type" : "string",
          "title" : "Key",
          "description" : "Property key"
        },
        "value" : {
          "type" : "string",
          "title" : "Value",
          "description" : "Property value"
        }
      },
      "required" : [ "key", "value" ]
    }
  }
}